# Greedy算法

1. 是一种编程范式，每次选择能带来直接利润/利益的步骤。它选择的是 "局部最优解"，而不考虑未来的后果。贪婪算法不一定能得到全局最优解。

2. 特点

   - 有一个有序的资源清单，比如利润，成本，价值等；
   - 取所有资源中的最大值。比如在 fractional knapsack 问题，根据可用容量，先取最大（价值/重量）

3. 优点

   - 实现简单
   - 时间复杂度低
   - 可用于优化的目的，或者在NP Hard问题的情况下寻找接近优化的方法

4. 缺点：可能不是全局最优

5. 基本结构

   ```java
   getOptimal(Item, arr[], int n)
     1) Initialize empty result : result = {}  
     2) While (All items are not considered)
   
         // We make a greedy choice to select
         // an item.
         i = SelectAnItem() 
   
         // If i is feasible, add i to the 
         // result
         if (feasible(i))
           result = result U i 
     3) return result
   ```

6. 应用

   1. **Kruskal的最小生成树**（MST）：在Kruskal的算法中，我们通过一一挑选边来创建MST。贪婪的选择是选择迄今为止不会造成MST周期变化的最小重量边。
   2. **Prim算法**：，我们通过一一挑选边来创建MST。我们维护两组：一组已经包含在MST中的顶点和一组尚未包含的顶点。贪婪的选择是选择连接两组的最小重量边。不依赖于|E|，因此适用于求解边稠密的图的最小生成树。
   3. **Dijkstra的最短路径**：Dijkstra的算法与Prim的算法非常相似。一条最短的路径树会逐步建立。我们维护两组：一组已经包含在树中的顶点和一组尚未包含的顶点。贪婪的选择是选择连接两个集合的边，并且该边在从源到包含尚未包含顶点的集合的最小权重路径上。
   4. **Huffman编码**：Huffman编码是一种无损压缩技术。它将可变长度的位代码分配给不同的字符。贪婪的选择是将最小位长的代码分配给最频繁的字符。
   5. 有时，贪婪算法也可用于获得Hard优化问题的近似值。例如，**旅行商问题**是NP-难问题。解决此问题的一个贪婪选择是在每一步中从当前城市中选择最近的未访问城市。这种解决方案并不总是能产生最佳的最佳解决方案，但可以用来获得近似最佳的解决方案。