package Dynamic;

/**
 * 下面介绍这个著名谜题的实例，涉及n=2个鸡蛋和一栋k=36层的大楼。
 * 假设我们想知道在一栋36层的大楼中，从哪几层楼扔鸡蛋是安全的，哪几层楼会导致鸡蛋落地时破碎。我们做一些假设。
 *
 * ..... 摔下来的鸡蛋还可以再使用。
 * .....一个摔碎的鸡蛋必须被丢弃。
 * .....对所有鸡蛋来说，摔倒的效果都是一样的。
 * .....如果一个鸡蛋掉下来会碎，那么从更高的楼层掉下来也会碎。
 * .....如果一个鸡蛋摔下来能活下来，那么它摔下来的时间就会短一些。
 * .....不排除一楼的窗户会摔坏鸡蛋，也不排除36楼不会导致鸡蛋破碎。
 *
 * 如果只有一个鸡蛋，而我们又希望确定得到正确的结果，那么实验只能用一种方法进行。将鸡蛋从一楼的窗户扔下去，如果它还能存活，就从二楼的窗户扔下去。继续向上，直到它破碎。
 * 在最坏的情况下，这种方法可能需要36次投掷。假设有2个鸡蛋。保证在所有情况下，最少的实验次数是多少？
 * 问题实际上并不是要找到临界层，而仅仅是要决定应该从哪些楼层落蛋，以便使总的试验次数最少。
 *
 *
 * 如果我们尝试从'1'楼投掷。
 * 最坏情况下的投掷次数=1+max(0, 1)
 * 0=>如果鸡蛋从第一层楼断裂，那么它就是门槛层（最好的情况）。
 * 1=>如果鸡蛋没有从一楼破损，我们现在有'2'个鸡蛋和1层楼要测试，答案为
 * '1'.(最坏情况的可能性)
 * 我们考虑到了最坏的可能，所以1+max(0，1)=2
 *
 * 如果我们尝试从'2'楼投掷。
 * 最坏情况下的投掷次数=1+max(1, 0)
 * 1=>如果鸡蛋从二楼断裂，那么我们将有1个鸡蛋和1个楼层来寻找门槛楼层。 (最坏情况)
 * 0=>如果鸡蛋没有从二楼破损，那么它就是门槛楼。
 * 我们取最坏情况下的可能性作为保证，所以1+max(1，0)=2。
 *
 * 最后的答案是min(1，2，3.....，第k层)
 * 所以这里的答案是 "2"。
 *
 * 当我们从x楼掉下一个鸡蛋时，可能有两种情况 (1)鸡蛋碎了 (2)鸡蛋没有碎。
 * 1）如果鸡蛋从'第x层'掉落后破碎，那么我们只需要检查比'x'更低的楼层，还有剩余的鸡蛋，因为应该有一些比'x'更低的楼层存在，在这些楼层中鸡蛋不会破碎，所以问题减少到x-1层和n-1个鸡蛋。
 * 2）如果鸡蛋从'x'层掉下来后没有破损，那么我们只需要检查比'x'层高的楼层，所以问题减少到'k-x'层和n个鸡蛋。
 * 由于我们需要在最坏的情况下尽量减少试验次数，我们取两种情况的最大值。我们考虑上述两种情况下每层的最大值，并选择产生最少试验次数的楼层。
 * eggDrop(n, k) = 1 + min{max(eggDrop(n – 1, x – 1), eggDrop(n, k – x)), where x is in {1, 2, …, k}}
 *               = min{ 1+ max(eggDrop(n – 1, x – 1), eggDrop(n, k – x) }
 * 综上所述先求出最坏情况，然后在这些最坏情况中选择最小的次数
 * E(2,10)结果为4，表明最坏情况下最少实验次数为4，我们可以选择从第四层开始实验
 */
public class EggDroppingPuzzle {
    /**
     *
     * @param n 鸡蛋个数
     * @param k 楼层数
     * @return 最少次数
     */
    public static int eggDrop(int n, int k){
        //楼层为0，实验次数为0，楼层为1，实验次数为1
        if(k==1||k==0){
            return k;
        }
        //鸡蛋只有一个，只能一层一层尝试，故次数为楼层数k
        if(n==1){
            return k;
        }
        int min=Integer.MAX_VALUE;
        int res=0;
        for(int x=1;x<=k;x++){
            res=Math.max(eggDrop(n-1,x-1),eggDrop(n,k-x));
            if(res<min){
                min=res;
            }
        }
        return min+1;
    }
    /**
     * DP
     *
     * @param n
     * @param k
     * @return
     */
    public static int eggDropDP(int n,int k){
        //i表示鸡蛋数,j表示楼层数
        int i,j,res=0;
        //table存放最少次数
        int[][] table=new int[n+1][k+1];
        //楼层为0，实验次数为0，楼层为1，实验次数为1
        for(i=1;i<=n;i++){
            table[i][0]=0;
            table[i][1]=1;
        }
        //一个鸡蛋有多少楼层，实验多少次
        for(j=1;j<=k;j++){
            table[1][j]=j;
        }
        for(i=2;i<=n;i++){
            for(j=2;j<=k;j++){
                table[i][j]=Integer.MAX_VALUE;
                for(int x=1;x<=j;x++){
                    res=1+Math.max(table[i-1][x-1],table[i][j-x]);
                    if(res<table[i][j]){
                        table[i][j]=res;
                    }
                }
            }
        }
        return table[n][k];
    }
    public static void main(String[] args)
    {
        int n = 2, k = 10;
        System.out.print("Minimum number of "
                + "trials in worst case with "
                + n + " eggs and " + k
                + " floors is " + eggDropDP(n, k));
    }
}
